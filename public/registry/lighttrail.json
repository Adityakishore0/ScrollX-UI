{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "lighttrail",
  "type": "registry:component",
  "title": "Light Trail",
  "description": "A scroll-driven image showcase with animated progress indicator",
  "author": "Ahdeetai <https://aditya.is-cool.devis>",
  "dependencies": ["framer-motion"],
  "files": [
    {
      "type": "registry:component",
      "path": "components/ui/lighttrail.tsx",
      "target": "components/ui/lighttrail.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport {\n  motion,\n  useTransform,\n  useScroll,\n  useSpring,\n  AnimatePresence,\n} from \"framer-motion\";\n\nconst cn = (...classes: string[]): string => {\n  return classes.filter(Boolean).join(\" \");\n};\n\ninterface ImageType {\n  id: number;\n  src: string;\n  alt: string;\n}\n\ninterface LightTrailProps {\n  className?: string;\n  title?: string;\n  description?: string;\n  images?: ImageType[];\n  containerHeight?: string;\n  scrollHeight?: string;\n}\n\nexport const LightTrail: React.FC<LightTrailProps> = ({\n  className = \"\",\n  title = \"Mountains\",\n  description = \"Mountains are large natural elevations of the earth's surface that rise prominently above their surroundings.\",\n  images = [\n    {\n      id: 1,\n      src: \"https://images.unsplash.com/photo-1469474968028-56623f02e42e?auto=format&fit=crop&q=80&w=3506&ixlib=rb-4.0.3\",\n      alt: \"Mountain forest with sunlight through trees\",\n    },\n    {\n      id: 2,\n      src: \"https://images.unsplash.com/photo-1519681393784-d120267933ba?auto=format&fit=crop&q=80&w=3540&ixlib=rb-4.0.3\",\n      alt: \"Snowy mountain peaks at night with starry sky\",\n    },\n    {\n      id: 3,\n      src: \"https://images.unsplash.com/photo-1464822759023-fed622ff2c3b?auto=format&fit=crop&q=80&w=3540&ixlib=rb-4.0.3\",\n      alt: \"Dramatic mountain landscape with clouds\",\n    },\n  ],\n  containerHeight = \"100%\",\n  scrollHeight = \"200vh\",\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const contentRef = useRef<HTMLDivElement>(null);\n  const stickyRef = useRef<HTMLDivElement>(null);\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const prevScrollY = useRef<number>(0);\n  const isInViewRef = useRef<boolean>(false);\n\n  const [svgWidth, setSvgWidth] = useState<number>(0);\n  const [currentImageIndex, setCurrentImageIndex] = useState<number>(0);\n  const [direction, setDirection] = useState<\"up\" | \"down\">(\"down\");\n  const [showTealLine, setShowTealLine] = useState<boolean>(false);\n  const [stickyTranslateY, setStickyTranslateY] = useState<number>(0);\n  const [isExitingSticky, setIsExitingSticky] = useState<boolean>(false);\n  const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });\n\n  const scrollableRange = 0.85;\n  const progressPerImage = scrollableRange / images.length;\n\n  const { scrollYProgress, scrollY } = useScroll({\n    target: containerRef,\n    offset: [\"start start\", \"end start\"],\n    container: wrapperRef,\n  });\n\n  useEffect(() => {\n    if (wrapperRef.current) {\n      const wrapper = wrapperRef.current;\n\n      const updateSize = () => {\n        if (wrapper) {\n          setContainerSize({\n            width: wrapper.offsetWidth,\n            height: wrapper.offsetHeight,\n          });\n        }\n      };\n\n      updateSize();\n      const resizeObserver = new ResizeObserver(updateSize);\n      resizeObserver.observe(wrapper);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, []);\n\n  useEffect(() => {\n    if (contentRef.current) {\n      const content = contentRef.current;\n      setSvgWidth(content.offsetWidth);\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        for (const entry of entries) {\n          setSvgWidth(entry.contentRect.width);\n        }\n      });\n\n      resizeObserver.observe(content);\n      return () => resizeObserver.disconnect();\n    }\n  }, [containerSize]);\n\n  useEffect(() => {\n    if (stickyRef.current) {\n      const stickyElement = stickyRef.current;\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            isInViewRef.current = entry.isIntersecting;\n          });\n        },\n        { threshold: 0.5 }\n      );\n\n      observer.observe(stickyElement);\n      return () => observer.disconnect();\n    }\n  }, []);\n\n  useEffect(() => {\n    const handleScroll = () => {\n      if (!isInViewRef.current) return;\n\n      const currentScrollY = scrollY.get();\n      if (currentScrollY > prevScrollY.current) {\n        setDirection(\"down\");\n      } else {\n        setDirection(\"up\");\n      }\n      prevScrollY.current = currentScrollY;\n\n      if (scrollYProgress.get() > 0.01 && !showTealLine) {\n        setShowTealLine(true);\n      }\n\n      const progress = scrollYProgress.get();\n      const normalizedProgress = Math.min(progress / scrollableRange, 1);\n      const imageIndex = Math.min(\n        Math.floor(normalizedProgress * images.length),\n        images.length - 1\n      );\n\n      if (imageIndex >= 0 && imageIndex !== currentImageIndex) {\n        setCurrentImageIndex(imageIndex);\n      }\n\n      if (progress > 0.95) {\n        setIsExitingSticky(false);\n        const exitProgress = (progress - 0.85) / 0.15;\n        const translateY = Math.min(exitProgress * -100, 0);\n        setStickyTranslateY(translateY);\n      } else {\n        setIsExitingSticky(false);\n        setStickyTranslateY(0);\n      }\n    };\n\n    const unsubscribe = scrollY.onChange(handleScroll);\n    return () => unsubscribe();\n  }, [scrollY, scrollYProgress, progressPerImage, images.length, currentImageIndex, showTealLine]);\n\n  const x2 = useTransform(scrollYProgress, [0, scrollableRange], [0, svgWidth - 100]);\n  const tealLineWidth = useTransform(scrollYProgress, [0, scrollableRange], [0, svgWidth]);\n\n  const springX2 = useSpring(x2, { stiffness: 700, damping: 70 });\n  const springTealLineWidth = useSpring(tealLineWidth, { stiffness: 700, damping: 70 });\n\n  const imageVariants = {\n    enter: (customDirection: \"up\" | \"down\") => ({ x: customDirection === \"down\" ? 50 : -50, opacity: 0 }),\n    center: {\n      x: 0,\n      opacity: 1,\n      transition: { type: \"spring\", stiffness: 500, damping: 30, duration: 0.2 },\n    },\n    exit: (customDirection: \"up\" | \"down\") => ({\n      x: customDirection === \"down\" ? -50 : 50,\n      opacity: 0,\n      transition: { type: \"spring\", stiffness: 500, damping: 30, duration: 0.2 },\n    }),\n  };\n\n  const getTealLineOffset = (value: number): number => {\n    return svgWidth - value * ((currentImageIndex + 1) / images.length);\n  };\n\n  const getStickyStyle = () => {\n    if (containerSize.height < 500) {\n      return { position: \"relative\" as const, top: 0, height: \"auto\" };\n    }\n    return {\n      position: \"sticky\" as const,\n      top: 0,\n      height: containerSize.height ? `${Math.min(containerSize.height, 600)}px` : \"auto\",\n    };\n  };\n\n  return (\n    <div ref={wrapperRef} className=\"relative overflow-auto w-full\" style={{ height: containerHeight }}>\n      <div className=\"w-full px-4 py-6\">\n        <div ref={containerRef} className=\"relative\" style={{ height: scrollHeight }}>\n          <motion.div\n            ref={stickyRef}\n            className={cn(\"flex items-center justify-center w-full\", isExitingSticky ? \"\" : \"transition-opacity duration-300\")}\n            style={{\n              ...getStickyStyle(),\n              translateY: containerSize.height ? `${(stickyTranslateY * containerSize.height) / 100}px` : 0,\n              opacity: isExitingSticky ? 1 - Math.abs(stickyTranslateY) / 100 : 1,\n            }}\n          >\n            <motion.div className={cn(\"relative mx-auto w-full h-full flex items-center\", className)}>\n              <div ref={contentRef} className=\"relative overflow-hidden w-full\">\n                <h1 className=\"mb-4 text-3xl md:text-5xl font-bold italic\">{title}</h1>\n                <p className=\"mb-6 md:mb-12 text-lg md:text-xl hover:underline\">{description}</p>\n\n                <div className=\"w-full mb-6 flex items-center\">\n                  <motion.div transition={{ duration: 0.1 }} className=\"flex h-4 w-4 items-center justify-center rounded-full border border-neutral-200 shadow-sm bg-white mr-0 z-10\">\n                    <motion.div\n                      transition={{ duration: 0.1 }}\n                      animate={{ backgroundColor: showTealLine ? \"#10b981\" : \"#FFFFFF\", borderColor: showTealLine ? \"#059669\" : \"#e5e5e5\" }}\n                      className=\"h-2 w-2 rounded-full border border-neutral-300\"\n                    />\n                  </motion.div>\n\n                  <svg viewBox={`0 0 ${svgWidth} 2`} width={svgWidth - 8} height=\"2\" className=\"block\" aria-hidden=\"true\" style={{ marginLeft: \"-4px\" }}>\n                    <motion.path d={`M 0 1 H ${svgWidth}`} fill=\"none\" stroke=\"#9091A0\" strokeOpacity=\"0.16\" strokeWidth=\"2\"></motion.path>\n                    {showTealLine && (\n                      <motion.path\n                        d={`M 0 1 H ${(currentImageIndex + 1) * (svgWidth / images.length)}`}\n                        fill=\"none\"\n                        stroke=\"url(#horizontalGradient)\"\n                        strokeWidth=\"2\"\n                        strokeDasharray={svgWidth}\n                        strokeDashoffset={springTealLineWidth.get() ? getTealLineOffset(springTealLineWidth.get()) : svgWidth}\n                        className=\"motion-reduce:hidden\"\n                      ></motion.path>\n                    )}\n                    <defs>\n                      <motion.linearGradient id=\"horizontalGradient\" gradientUnits=\"userSpaceOnUse\" x1=\"0\" y1=\"0\" x2={springX2} y2=\"0\">\n                        <stop stopColor=\"#18CCFC\" stopOpacity=\"0\"></stop>\n                        <stop stopColor=\"#18CCFC\"></stop>\n                        <stop offset=\"0.325\" stopColor=\"#6344F5\"></stop>\n                        <stop offset=\"1\" stopColor=\"#AE48FF\" stopOpacity=\"0\"></stop>\n                      </motion.linearGradient>\n                    </defs>\n                  </svg>\n                </div>\n\n                <AnimatePresence initial={false} custom={direction} mode=\"wait\">\n                  <motion.div\n                    key={currentImageIndex}\n                    custom={direction}\n                    variants={imageVariants}\n                    initial=\"enter\"\n                    animate=\"center\"\n                    exit=\"exit\"\n                    className=\"w-full\"\n                  >\n                    <div className=\"relative aspect-[16/9] w-full overflow-hidden rounded-lg\">\n                      <img\n                        src={images[currentImageIndex].src}\n                        alt={images[currentImageIndex].alt}\n                        className=\"h-full w-full object-cover\"\n                      />\n                    </div>\n                  </motion.div>\n                </AnimatePresence>\n              </div>\n            </motion.div>\n          </motion.div>\n        </div>\n      </div>\n    </div>\n  );\n};"
    }
  ]
}
