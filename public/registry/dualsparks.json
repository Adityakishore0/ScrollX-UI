{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "dualsparks",
  "type": "registry:component",
  "title": "Dual Sparks",
  "description": "Corner-based spark waves that radiate inward and outward with smooth motion.",
  "author": "Ahdeetai <https://aditya.is-cool.dev>",
  "dependencies": [
    "clsx",
    "tailwind-merge"
  ],
  "files": [
    {
      "type": "registry:component",
      "path": "components/ui/dualsparks.tsx",
      "target": "components/ui/dualsparks.tsx",
      "content": "\"use client\";\n\nimport React, { useEffect, useRef, useCallback } from \"react\";\nimport { cn } from \"@/lib/utils\";\n\ninterface DualSparksProps {\n  sparkColor?: string;\n  sparkColorDark?: string;\n  sparkSize?: number;\n  sparkCount?: number;\n  duration?: number;\n  easing?: \"linear\" | \"ease-in\" | \"ease-out\" | \"ease-in-out\";\n  waveInterval?: number;\n  maxRadius?: number;\n  ringsPerWave?: number;\n  ringSpacing?: number;\n  enableInward?: boolean;\n  corners?: \"both\" | \"left\" | \"right\";\n  backgroundColor?: string;\n  backgroundColorDark?: string;\n  clearBackground?: boolean;\n  backgroundOpacity?: number;\n  className?: string;\n  children?: React.ReactNode;\n  forceDarkMode?: boolean;\n}\n\ninterface Spark {\n  x: number;\n  y: number;\n  angle: number;\n  radius: number;\n  startTime: number;\n  waveId: number;\n  ringIndex: number;\n  direction: \"outward\" | \"inward\";\n  corner: \"left\" | \"right\";\n}\n\nexport const DualSparks: React.FC<DualSparksProps> = ({\n  sparkColor = \"#000000\",\n  sparkColorDark = \"#ffffff\",\n  sparkSize = 10,\n  sparkCount = 24,\n  duration = 3500,\n  easing = \"ease-out\",\n  waveInterval = 1400,\n  maxRadius = 800,\n  ringsPerWave = 5,\n  ringSpacing = 40,\n  enableInward = true,\n  corners = \"both\",\n  backgroundColor = \"rgba(240, 240, 250, 0.15)\",\n  backgroundColorDark = \"rgba(0, 0, 0, 0.15)\",\n  clearBackground = true,\n  backgroundOpacity = 0.15,\n  className = \"\",\n  children,\n  forceDarkMode,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const sparksRef = useRef<Spark[]>([]);\n  const lastWaveTimeRef = useRef<number>(0);\n  const lastInwardWaveTimeRef = useRef<number>(700);\n  const waveIdRef = useRef<number>(0);\n  const containerWidthRef = useRef<number>(0);\n  const containerHeightRef = useRef<number>(0);\n  const animationIdRef = useRef<number>(0);\n\n  const isDarkMode = useCallback(() => {\n    if (forceDarkMode !== undefined) return forceDarkMode;\n    if (typeof document === \"undefined\") return false;\n    return document.documentElement.classList.contains(\"dark\");\n  }, [forceDarkMode]);\n\n  const getSparkColor = useCallback(() => {\n    return isDarkMode() ? sparkColorDark : sparkColor;\n  }, [isDarkMode, sparkColor, sparkColorDark]);\n\n  const getBackgroundColor = useCallback(() => {\n    const baseColor = isDarkMode() ? backgroundColorDark : backgroundColor;\n    const match = baseColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n    if (match && backgroundOpacity !== undefined) {\n      const [, r, g, b] = match;\n      return `rgba(${r}, ${g}, ${b}, ${backgroundOpacity})`;\n    }\n    return baseColor;\n  }, [isDarkMode, backgroundColor, backgroundColorDark, backgroundOpacity]);\n\n  const easeFunc = useCallback((t: number) => {\n    switch (easing) {\n      case \"linear\": return t;\n      case \"ease-in\": return t * t;\n      case \"ease-in-out\": return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n      default: return t * (2 - t);\n    }\n  }, [easing]);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const parent = canvas.parentElement;\n    if (!parent) return;\n\n    let resizeTimeout: NodeJS.Timeout;\n\n    const resizeCanvas = () => {\n      const { width, height } = parent.getBoundingClientRect();\n      canvas.width = width;\n      canvas.height = height;\n      containerWidthRef.current = width;\n      containerHeightRef.current = height;\n      sparksRef.current = [];\n      waveIdRef.current = 0;\n      lastWaveTimeRef.current = 0;\n      lastInwardWaveTimeRef.current = 700;\n    };\n\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(resizeCanvas, 100);\n    };\n\n    const ro = new ResizeObserver(handleResize);\n    ro.observe(parent);\n    window.addEventListener(\"resize\", handleResize);\n    resizeCanvas();\n\n    return () => {\n      ro.disconnect();\n      window.removeEventListener(\"resize\", handleResize);\n      clearTimeout(resizeTimeout);\n    };\n  }, []);\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext(\"2d\", { alpha: true });\n    if (!ctx) return;\n\n    const animate = (timestamp: number) => {\n      if (clearBackground) {\n        ctx.fillStyle = getBackgroundColor();\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n      } else {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n      }\n\n      const color = getSparkColor();\n\n      sparksRef.current = sparksRef.current.filter(spark => {\n        const elapsed = timestamp - spark.startTime;\n        if (elapsed < 0) return true;\n        if (elapsed >= duration) return false;\n\n        const progress = elapsed / duration;\n        const eased = easeFunc(progress);\n        const radius = spark.direction === \"outward\"\n          ? spark.radius + eased * maxRadius\n          : spark.radius - eased * maxRadius;\n\n        if (radius < 0) return false;\n\n        const opacity = progress < 0.6 ? 1 : 1 - (progress - 0.6) / 0.4;\n        const x1 = spark.x + radius * Math.cos(spark.angle);\n        const y1 = spark.y + radius * Math.sin(spark.angle);\n        const x2 = x1 + sparkSize * Math.cos(spark.angle);\n        const y2 = y1 + sparkSize * Math.sin(spark.angle);\n\n        ctx.strokeStyle = color;\n        ctx.globalAlpha = opacity;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n\n        return true;\n      });\n\n      ctx.globalAlpha = 1;\n      animationIdRef.current = requestAnimationFrame(animate);\n    };\n\n    animationIdRef.current = requestAnimationFrame(animate);\n    return () => cancelAnimationFrame(animationIdRef.current);\n  }, [sparkColor, sparkColorDark, duration, maxRadius, sparkSize, easeFunc, getSparkColor, getBackgroundColor, clearBackground]);\n\n  return (\n    <div className={cn(\"relative overflow-hidden\", className)}>\n      <canvas ref={canvasRef} className=\"absolute inset-0 w-full h-full\" />\n      {children && <div className=\"relative z-10\">{children}</div>}\n    </div>\n  );\n};"
    },
    {
      "type": "registry:lib",
      "path": "lib/utils.ts",
      "target": "lib/utils.ts",
      "content": "import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}"
    }
  ]
}
